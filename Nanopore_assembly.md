# NERC Bioinformatics Training: Nanopore Genome Assembly

In this practical you will assemble a genome from Oxford Nanopore long reads, assess its quality, and check for contamination. We will work through a complete pipeline from raw sequencing data to a polished assembly, using real data from the millipede *Glomeris pulchra*. 

## Table of Contents

1. [Before you start](#before-you-start)
2. [Set up directory](#set-up-directory)
3. [Set up conda environments](#set-up-conda-environments)
4. [Download Nanopore reads](#download-nanopore-reads)
5. [Trim adapters with Porechop](#trim-adapters-with-porechop)
6. [Read QC with NanoPlot](#read-qc-with-nanoplot)
7. [Filter reads with NanoFilt](#filter-reads-with-nanofilt)
8. [Assemble genome with Flye](#assemble-genome-with-flye)
9. [Polish assembly with Medaka](#polish-assembly-with-medaka)
10. [Assess completeness with BUSCO](#assess-completeness-with-busco)
11. [Run DIAMOND for taxonomic hits](#run-diamond-for-taxonomic-hits)
12. [Visual assessment with BlobTools](#visual-assessment-with-blobtools)
13. [Summary](#summary)

---

## Before you start

To complete this practical, you will need to have:
- Access to the Franklin HPC
- Installed conda
- Have a basic understanding of Linux commands.

## Set up directory

```bash
# change to home directory
cd ~

# make directory for main analysis
mkdir nerc_practical

# change to new directory
cd nerc_practical
```

---

## Set up conda environments

**Conda** is a package manager — a tool that installs, updates, and organises software for you. Rather than downloading and configuring each program manually, you can install it with a single command and conda handles all the dependencies automatically.

Conda also lets you create separate **environments**, each of which is an isolated collection of software with its own set of tools and versions. This is important in bioinformatics because different tools often require conflicting versions of the same dependency. By keeping each tool (or group of tools) in its own environment, you avoid these conflicts and can easily switch between them.

In this practical we will use three environments:
- `env_qc` - tools for read quality control
- `env_assembly` - tools for genome assembly and polishing
- `env_assess_genome` -tools for assessing the final assembly

I have created environment specification files in a shared directory, `cp` these to your directory.

```bash
# copy the environments folder from the shared training directory to your current directory
cp -r /hpc/groups/nerc-training/envs .
```

Now we can install all the environments we need for the practical. This can take a few minutes to install. 

```bash
# create the QC environment (tools for read trimming and quality checking)
conda env create -y -f envs/env_qc.yml

# create the assembly environment (tools for genome assembly and polishing)
conda env create -y -f envs/env_assembly.yml

# create the genome assessment environment (tools for BUSCO and BlobTools)
conda env create -y -f envs/env_assess_genome.yml
```

We can list the environments created using:

```bash
conda env list
```

To activate an environment use: 

```bash
conda activate env_qc
```

Notice how the prompt changes include "(env_qc)"

To deactivate use:
```bash
conda deactivate
```

---

## Download Nanopore reads

We are going to download sequencing reads from the [NCBI Sequence Read Archive (ERR15336157)](!https://www.ncbi.nlm.nih.gov/sra/ERR15336157). 

This data is from the species *Glomeris pulchra*, and was generated on an Oxford Nanopore PromethION, with a total size of 90.2G. 

We are only going to download a small number of reads (10,000). 
This dataset is too small to assemble a genome, but we are working with a small example dataset just to show how it would work in practice. 

Run in terminal:
```bash
# activate the QC conda environment
conda activate env_qc

# download the first 10,000 reads from accession ERR15336157
fastq-dump -X 10000 --outdir fastq_dump ERR15336157
```

Check output:
```bash
ls -lh fastq_dump/ERR15336157.fastq
```

---

## Trim adapters with Porechop

Nanopore reads are generated by sequencing DNA fragments that have short **adapter** sequences attached to their ends. These adapters are artificial pieces of DNA added during library preparation to help the reads attach to the sequencing pore — they are not part of the organism's genome and need to be removed before analysis.

**Porechop** detects and trims these adapter sequences from the raw reads. Leaving adapters in can cause problems downstream, such as poor assembly quality or misleading alignment results.

Run in terminal:
```bash
# create output directory
mkdir porechop_output

# trim adapters from reads
porechop -i fastq_dump/ERR15336157.fastq \
         -o porechop_output/ERR15336157.fastq \
         -t 4
```

Check output:
```bash
ls -lh porechop_output/ERR15336157.fastq
```

---

## Read QC with NanoPlot

Now that we have removed adapters, it is good practice to inspect the quality of our reads before proceeding. **NanoPlot** generates a set of interactive plots and statistics that summarise the read data, including:

- Read length distribution — how long are our reads?
- Read quality scores — how accurate are our reads?
- Total yield — how much data do we have in total?

This step helps you understand what you are working with and spot any potential issues before assembly. 

Run in terminal:
```bash
# generate QC plots and statistics for the trimmed reads
NanoPlot --fastq porechop_output/ERR15336157.fastq \
         -t 4 \
         -o nanoplot_output
```

Check output:
```bash
ls -lh nanoplot_output
```

Tip:
- Open the HTML file in `nanoplot_output/NanoPlot-report.html` using Filezilla to view read quality and read length distributions.

> **Discussion:** Look at the read length and quality distributions in the NanoPlot report.
> - What is the median read length and quality score?
> - Do you think these reads are suitable for genome assembly?
> - Would you change the filtering thresholds in the next step? Why?

---

## Filter reads with NanoFilt

Now that we have seen what our reads look like, we can remove low quality sequences before assembly. Not all reads are equally reliable — shorter reads and reads with low quality scores contribute less useful information and can introduce errors into the assembly.

**NanoFilt** filters reads based on minimum quality score and minimum length. Removing poor quality reads reduces noise and generally produces a cleaner, more accurate genome assembly. 

Run in terminal:
```bash
# create output directory
mkdir nanofilt_output

# keep only reads with quality >= 10 and length >= 20,000 bases
NanoFilt -q 10 -l 20000 porechop_output/ERR15336157.fastq > nanofilt_output/ERR15336157.fastq
```

Check output:
```bash
ls -lh nanofilt_output/ERR15336157.fastq
```

What this filter means:
- `-q 10` keeps reads with average quality score at least 10
- `-l 20000` keeps reads that are at least 20,000 bases long

---

## Assemble genome with Flye

With a clean set of reads, we can now attempt to reconstruct the genome. Genome assembly works by finding overlapping regions between reads and joining them together into longer continuous sequences called **contigs**.

**Flye** is an assembler designed specifically for long Nanopore reads. It works by building a graph of all the read overlaps and then simplifying that graph into a set of contigs. We also provide an estimated genome size (`150m` = 150 megabases) to help Flye optimise the assembly.

Note: the dataset we are using here is a small example only, so the assembly will not represent a complete or accurate genome — it is just to illustrate the process.

Run in terminal:
```bash
# switch to the assembly environment
conda deactivate
conda activate env_assembly

# assemble the genome from filtered reads (estimated size: 150 megabases)
flye --nano-raw nanofilt_output/ERR15336157.fastq \
     --out-dir flye_output \
     --genome-size 150m \
     --iterations 3 \
     --threads 4
```

Even though we are using a small dataset, this process can take a while.

Key output:
```bash
ls -lh flye_output/assembly.fasta
```

Flye also produces a useful summary of the assembly. Have a look:
```bash
cat flye_output/assembly_info.txt
```

You can also get a quick summary of contig statistics using `seqkit`:
```bash
seqkit stats -a flye_output/assembly.fasta
```

> **Discussion:** Look at the assembly statistics.
> - How many contigs were assembled?
> - What is the N50? (N50 is the length at which half of the total assembly is contained in contigs of that size or longer — a higher N50 generally means a more contiguous assembly)
> - What is the total assembly size compared to the expected genome size of ~150 Mb?

---

## Polish assembly with Medaka

Nanopore sequencing has a higher error rate compared to short-read technologies, which means the raw assembly from Flye will contain some sequencing errors — small insertions, deletions, or substitutions in the sequence. **Polishing** corrects these errors by re-aligning the original reads back to the assembly and using the consensus of those alignments to fix mistakes.

**Medaka** is a polishing tool developed by Oxford Nanopore Technologies. It uses a neural network trained on Nanopore data to identify and correct errors in the assembly, producing a more accurate final sequence.

Run in terminal:
```bash
# polish the assembly by re-aligning the original reads
medaka_consensus -i nanofilt_output/ERR15336157.fastq \
                 -d flye_output/assembly.fasta \
                 -o medaka \
                 -t 4
```

Key output:
```bash
ls -lh medaka/consensus.fasta
```

---

## Assess completeness with BUSCO

We now have an assembled and polished genome sequence. But how do we know if it is complete? One widely used approach is to search for **BUSCO genes** (Benchmarking Universal Single-Copy Orthologs). These are genes that are expected to be present in single copy in nearly all species within a particular lineage. If most of them are found in your assembly, it suggests the assembly is reasonably complete.

**BUSCO** searches your assembly against a database of these expected genes and reports how many are:
- **Complete** — found in full
- **Fragmented** — partially found
- **Missing** — not found at all

A high percentage of complete BUSCOs is a good sign. A large number of missing or fragmented BUSCOs may indicate an incomplete assembly.

As our example dataset is too small to produce a good assembly, we will switch to using a pre-prepared assembly at `/hpc/groups/nerc-training/medaka/consensus.fasta` to get meaningful results.

Run in terminal:
```bash
# switch to the genome assessment environment
conda deactivate
conda activate env_assess_genome

# search for conserved arthropod genes to assess assembly completeness
busco \
   -i /hpc/groups/nerc-training/medaka/consensus.fasta \
   -l arthropoda_odb10/ \
   --download_path /hpc/groups/nerc-training/busco_downloads \
   -o busco_output \
   -m genome \
   --metaeuk \
   --offline \
   --cpu 8 \
   -f
```

This analysis can take some time — typically 20–40 minutes. If you don't have the time to wait, cancel the command with `Ctrl+C` and check the output files in `/hpc/groups/nerc-training/busco_output/`

Key output for BUSCO extraction:
```bash
ls -lh /hpc/groups/nerc-training/busco_output/busco_output/run_arthropoda_odb10/full_table.tsv
```

You can print a quick summary of the BUSCO results directly in the terminal:
```bash
cat /hpc/groups/nerc-training/busco_output/busco_output/run_arthropoda_odb10/short_summary*.txt
```

> **Discussion:** Look at the BUSCO summary.
> - What percentage of BUSCOs are complete?
> - For a good quality arthropod assembly, we would typically expect >90% complete BUSCOs. How does this assembly compare?
> - What might cause a high number of fragmented or missing BUSCOs?

---

## Run DIAMOND for taxonomic hits

Another way to assess assembly quality — and check for contamination — is to compare the assembled sequences against a database of known proteins. This tells us what organisms the sequences likely came from.

**DIAMOND** is a fast alternative to BLAST that performs the same type of sequence similarity search but much more quickly, making it practical for large assemblies. Here we run a `blastx` search, which translates our DNA sequences into protein sequences and compares them against the **UniProt** database — a comprehensive, well-curated database of protein sequences from across the tree of life.

The result is a table of best hits telling us which organism each contig most closely matches. 

Run in terminal:
```bash
# create output directory
mkdir diamond_output

# search assembly against UniProt to find the best taxonomic hit for each contig
diamond blastx \
  --query /hpc/groups/nerc-training/medaka/consensus.fasta \
  --db /hpc/groups/nerc-training/uniprot.dmnd \
  --outfmt 6 qseqid staxids bitscore qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore \
  --max-target-seqs 1 \
  --evalue 1e-25 \
  --threads 4 > diamond_output/diamond.txt
```

As with BUSCO, a DIAMOND search of a genome can take a while. If you don't have time to finish the analysis, cancel the run with `Ctrl+C` and use the example output provided at `/hpc/groups/nerc-training/diamond_output`

Check output:
```bash
ls -lh /hpc/groups/nerc-training/diamond_output/diamond_output/diamond.txt
head -n 5 /hpc/groups/nerc-training/diamond_output/diamond_output/diamond.txt
```

---

## Visual assessment with BlobTools

**BlobTools** is a widely used tool for evaluating genome assemblies. It combines three sources of information for each contig in the assembly:

1. **Taxonomic identity** — from the DIAMOND hits
2. **Sequencing coverage** — how many reads mapped back to each contig
3. **GC content** — the proportion of G and C bases in the sequence

By plotting these together, BlobTools produces a "blobplot" that makes it easy to spot contamination. Genuine target sequences tend to cluster together with similar GC content and coverage. Contigs from contaminant organisms (for example bacteria in a sample meant to contain only the target species) typically appear as separate clusters with different GC content or coverage. 

Run in terminal:
```bash
# step 1: build a BlobTools dataset combining assembly, taxonomy, coverage and BUSCO
blobtools create \
  --fasta /hpc/groups/nerc-training/medaka/consensus.fasta \
  --hits /hpc/groups/nerc-training/diamond_output/diamond.txt \
  --taxrule bestsumorder \
  --taxdump /hpc/groups/nerc-training/taxdump \
  --cov /hpc/groups/nerc-training/medaka/calls_to_draft.bam \
  --busco /hpc/groups/nerc-training/busco_output/run_arthropoda_odb10/full_table.tsv \
  blobtools_output

# step 2: export a summary table of per-contig statistics
blobtools filter \
  --table blobtools_output/table.tsv \
  --table-fields gc,length,calls_to_draft_cov,bestsumorder_superkingdom,bestsumorder_kingdom,bestsumorder_phylum,bestsumorder_class,bestsumorder_order,bestsumorder_family,bestsumorder_species \
  blobtools_output

# step 3: generate the blobplot
blobtools view --plot blobtools_output/
```



Check output:
```bash
ls -lh blobtools_output
```

The blobplot image will be saved as `blobtools_output/blobtools_output.blob.circle.png`. Download this file using Filezilla to view it.

### How to interpret the blobplot

Each circle in the plot represents one contig from your assembly. The axes and visual properties encode different pieces of information:

- **X-axis (GC content):** The proportion of G and C bases in the contig. Different organisms have characteristic GC profiles — for example, many bacteria have very different GC content from arthropods.
- **Y-axis (coverage):** How many reads mapped back to that contig. Genuine target sequences tend to have high, consistent coverage. Contaminants often appear at unexpectedly low or high coverage.
- **Circle size:** Proportional to the length of the contig — larger circles represent longer contigs.
- **Circle colour:** The predicted taxonomic origin of the contig, based on the DIAMOND hits.

**What to look for:**

| Pattern | What it suggests |
|---------|-----------------|
| One large cluster of similarly coloured circles | Clean assembly, most contigs came from your target organism |
| A separate cluster with different GC content or coverage | Possible contamination from another organism |
| Many small grey circles (no hit) | Contigs with no DIAMOND match — may be novel, poorly assembled, or very divergent |
| Circles labelled as bacteria at low coverage | Likely bacterial contamination from the sample |

A clean assembly of an arthropod should show a dominant cluster at a GC content typical for that lineage (~30–40%), with high, consistent coverage, and most contigs coloured as Arthropoda.

> **Discussion:** Look at your blobplot.
> - Are there any contigs that stand out as potential contaminants?
> - What is the approximate GC content of the main cluster?
> - Are there any contigs with very different coverage from the rest? What might explain this?

---

## Summary

You have now completed a full Nanopore genome assembly workflow. Here is a recap of what was produced at each stage:

| Step | Tool | Key output |
|------|------|------------|
| Download reads | fastq-dump | `fastq_dump/ERR15336157.fastq` |
| Trim adapters | Porechop | `porechop_output/ERR15336157.fastq` |
| Read QC | NanoPlot | `nanoplot_output/NanoPlot-report.html` |
| Filter reads | NanoFilt | `nanofilt_output/ERR15336157.fastq` |
| Assemble genome | Flye | `flye_output/assembly.fasta` |
| Polish assembly | Medaka | `medaka/consensus.fasta` |
| Assess completeness | BUSCO | `busco_output/run_arthropoda_odb10/short_summary*.txt` |
| Taxonomic hits | DIAMOND | `diamond_output/diamond.txt` |
| Visual assessment | BlobTools | `blobtools_output/` |

---
